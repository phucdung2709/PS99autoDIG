local PATROL_POINTS = {
    Vector3.new(80.87, 0.42, -36.25),
    Vector3.new(95.24, 0.42, 84.61),
    Vector3.new(-118.13, 0.05, 106.55),
    Vector3.new(-83.54, 0.00, -26.32),
}

local JUMP_PERIOD = 5
local ROLL_PERIOD = 30
local CHAT_PERIOD = 180
local CHAT_MESSAGES = {
    "Hi! B·∫°n t√™n g√¨ trong ƒë·ªùi th·∫≠t? M√¨nh t√™n l√† [T√™n b·∫°n]!",
    "B·∫°n ch∆°i game n√†y l√¢u ch∆∞a? M√¨nh m·ªõi ch∆°i √° üòÖ",
    "C√≥ mu·ªën l·∫≠p team c√πng m√¨nh kh√¥ng?",
    "B·∫°n c√≥ Discord kh√¥ng? K·∫øt b·∫°n n√≥i chuy·ªán cho ti·ªán!",
    "Skin b·∫°n ƒë·∫πp qu√°! B·∫°n l√†m sao c√≥ ƒë∆∞·ª£c th·∫ø?",
    "Ch∆°i vui v·∫ª nha m·ªçi ng∆∞·ªùi!",
    "C·∫©n th·∫≠n nha, ƒëo·∫°n n√†y kh√≥ √°!",
    "M√¨nh lag x√≠u, ƒë·ª£i m√¨nh v·ªõi üòÖ",
    "C√≥ ai ch·ªâ m√¨nh c√°ch ch∆°i ƒëo·∫°n n√†y kh√¥ng?",
    "L√°t m√¨nh tho√°t nha, mai g·∫∑p l·∫°i nh√©! Add friend m√¨nh nha!",
}


local EGG_REMOTE_PATH = { "Network", "Eggs_Roll" }
local EGG_ROLL_ARGUMENTS = nil

local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local channel = TextChatService:FindFirstChild("TextChannels")
              and TextChatService.TextChannels:FindFirstChild("RBXGeneral")

if channel then
    task.spawn(function()
        while true do
            task.wait(CHAT_PERIOD)
            local msg = CHAT_MESSAGES[math.random(#CHAT_MESSAGES)]
            pcall(function() channel:SendAsync(msg) end)
        end
    end)
end
local function startEggRolling()
    local remote = ReplicatedStorage
    for _, name in ipairs(EGG_REMOTE_PATH) do
        remote = remote:FindFirstChild(name)
        if not remote then
            warn("[EggRoll] Kh√¥ng t√¨m th·∫•y:", name)
            return
        end
    end

    task.spawn(function()
        while true do
            task.wait(ROLL_PERIOD)
            pcall(function()
                if EGG_ROLL_ARGUMENTS then
                    remote:InvokeServer(table.unpack(EGG_ROLL_ARGUMENTS))
                else
                    remote:InvokeServer()
                end
            end)
        end
    end)
end
startEggRolling()
local function setupCharacter(char)
    local humanoid = char:WaitForChild("Humanoid")
    local rootPart = char:WaitForChild("HumanoidRootPart")

    local function walkTo(target)
        local path = PathfindingService:CreatePath{
            AgentRadius = 2, AgentHeight = 5, AgentCanJump = true
        }
        path:ComputeAsync(rootPart.Position, target)
        if path.Status ~= Enum.PathStatus.Success then return false end
        local blocked = false
        local conn = path.Blocked:Connect(function() blocked = true end)
        for _, wp in ipairs(path:GetWaypoints()) do
            if blocked then break end
            humanoid:MoveTo(wp.Position)
            if wp.Action == Enum.PathWaypointAction.Jump then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
            if not humanoid.MoveToFinished:Wait() then break end
        end
        conn:Disconnect()
    end

    task.spawn(function()
        while char.Parent do
            task.wait(JUMP_PERIOD)
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end)

    task.spawn(function()
        local i = 1
        while char.Parent do
            walkTo(PATROL_POINTS[i])
            i = (i % #PATROL_POINTS) + 1
            task.wait(1)
        end
    end)
end

player.CharacterAdded:Connect(setupCharacter)
if player.Character then setupCharacter(player.Character) end
